---
title: "run_jm"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
#install.packages("joineRML")
library(joineRML)


select <- dplyr::select
```



https://cran.r-project.org/web/packages/joineRML/index.html

# Example from vignette
https://cran.r-project.org/web/packages/joineRML/vignettes/joineRML.html

```{r}
data("heart.valve")

hvd <- heart.valve[!is.na(heart.valve$grad) & !is.na(heart.valve$lvmi), ]

hvd %>% head()

dim(hvd)

# num is the subject id
hvd$num %>% unique() %>% length()
```

```{r}
any(is.na(hvd))
```


```{r}
hvd %>%
  group_by(num) %>%
  summarise(obs = n()) %>%
  ggplot() + geom_point(aes(x = num, y = obs))
```



```{r}

t.start <- Sys.time()

set.seed(12345)
fit <- mjoint(
  formLongFixed = list("grad" = log.grad ~ time + sex + hs, 
                       "lvmi" = log.lvmi ~ time + sex),
  formLongRandom = list("grad" = ~ 1 | num,
                        "lvmi" = ~ time | num),
  formSurv = Surv(fuyrs, status) ~ age, # follow up years
  data = list(hvd, hvd),
  inits = list("gamma" = c(0.11, 1.51, 0.80)),
  timeVar = "time")

t.end <- Sys.time()
```




```{r}
cat("Completed in", difftime(t.end, t.start, units = "secs"), "sec")
```


# ADNI

```{r}
load("C:/Users/ybfen/Documents/GitHub/thesis_CompareSurvivalModels/data_cleaned/adni_cleaned.RData")

# df.long_censored %>% dim()
```



```{r, eval=FALSE}
# Remove NA, why is it required?
df.long_censored_jm <- df.long_censored[
  !is.na(df.long_censored$ADAS13) & !is.na(df.long_censored$MMSE), ]
```

//Strictly speaking, this is not necessary because joineRML can handle the situation of different measurement schedules within subjects That is, a subject does not need to have all multiple longitudinal outcomes recorded at each visit. It is conceivable that some biomarkers will be measured more or less frequently than others. For example, invasive measurements may only be recorded annually, whereas a simple biomarker measurement might be recorded more frequently. joineRML can handle this situation by specifying each longitudinal outcome its own data frame.

```{r}
#n <- 250

ids.all <- df.surv_preds$id

df.long_censored <- df.long_censored_transformed # Use transformed

df.surv_preds <- df.surv_preds %>%
  mutate(age.fup = time + AGE) %>%
  select(id, time, age.fup, everything())

# variables to keep in the df feed to mjoint
baseline.covs <- c("AGE", "PTGENDER", "PTEDUCAT", "status.bl", "APOE4")
keep_ids <- c("id", "time", "event", "age.fup", "Years.bl", baseline.covs)
long.covs <- c("ADAS13", "MMSE")


# here i need to filter out the NAs for each long covariate repectively
list.df.no_NA <- lapply(long.covs, function(y) {

  # remove na
  df.tmp <- df.long_censored[!is.na(df.long_censored[, y]), ]
  
  ids.tmp <- unique(df.tmp$id)
  
  # Check if mean imputation at baseline is needed when any subject does not have a measurement for y
  # when removing NAs, some subjects may be removed because they don't have any long measurements at all
  print(length(ids.tmp) - length(ids.all)) # Check, negative => missing subjects => imputation needed
  if (length(ids.tmp) < length(ids.all)) {
    y.mean <- mean(df.long_censored[df.long_censored$VISCODE == "bl", y], na.rm = TRUE)
    # Manually modify
    ids.impute <- ids.all[!ids.all %in% ids.tmp]

    df.impute <- df.long_censored %>% # Impute at baseline and maintain same data format
      filter(id %in% ids.impute) %>%
      filter(VISCODE == "bl")
  
#    df.impute %>% 
#      select(!!rlang::enquo(y))

#    this cannot copy label and class attributes
#    df.impute <- df.impute %>%
#      mutate(across(.cols = all_of(y), .fns = function(x) y.mean))
    
    df.impute[, y] <- y.mean # Impute

    # Because ADNI dataframe is labelled. It's probably better to remove all labels at first?
#    df.impute <- sjlabelled::copy_labels(df_new = df.impute, df_origin = df.long_censored)
        
    df.tmp <- rbind(df.tmp, df.impute) %>%
      arrange(id, Years.bl)
    
    print(paste("Subjects after imputation =", length(unique(df.tmp$id)))) # After imputation
  }

  # drop irrelevant data
  df.tmp <- df.tmp[, c(keep_ids, y)]
  
  return(df.tmp)
})


  
# Check after subset
sapply(list.df.no_NA, function(x) {
  print(dim(x))
  print(length(unique(x$id)))
  
  return(NULL)
})

# save memory
rm(df.long_censored, df.long_censored_transformed)

df.surv_preds <- df.surv_preds %>%
  select(all_of(keep_ids))

```




error encountered:
Error in mjoint(formLongFixed = list(ADAS13 = ADAS13 ~ age.fup, MMSE = MMSE ~ : 
Every subject must have at least one measurement per each outcome

solution: checking and imputation

error encountered:
when i specify formLongRandom ~ age.fup | id
Error in eval(predvars, data, env) : object 'age.fup' not found
solution: forget to specify timevar as age.fup

error encountered:
Running multivariate LMM EM algorithm to establish initial parameters...
Error in solve.default(D) : 
  system is computationally singular: reciprocal condition number = 2.21955e-16
comment: this happen to transformed data, with two long covariates

then i tried a non-transformed data
so far i get:
Running multivariate LMM EM algorithm to establish initial parameters...
Finished multivariate LMM EM algorithm...
Data are unbalanced... using sub-optimal initial parameters for gamma

```{r}
t.start <- Sys.time()

fit.joineRML = mjoint(
  # a list of formulae for the fixed effects component of each longitudinal outcome
  # The left hand-hand side defines the response, and the right-hand side specifies the fixed effect terms
  formLongFixed = list(
    "ADAS13" = ADAS13 ~ age.fup, 
    "MMSE" = MMSE ~ age.fup),
  # a list of one-sided formulae specifying the model for the random effects effects of each longitudinal outcome.
  formLongRandom = list( 
    "ADAS13" = ~ age.fup | id, 
    "MMSE" = ~ age.fup | id),
  formSurv = Surv(age.fup, event) ~ AGE + PTGENDER + PTEDUCAT + status.bl + APOE4,
  #  list of data.frame objects for each longitudinal outcome in which to interpret the variables named in the formLongFixed and formLongRandom.
  #  If the multiple longitudinal outcomes are measured at the same time points for each patient, then a data.frame object can be given instead of a list
  data = list.df.no_NA,
  survData = df.surv_preds,
  timeVar = "age.fup") # Did not use age.fup as time variable in LMM, due to error

t.end <- Sys.time()

cat("Completed in", difftime(t.end, t.start, units = "mins"), "min")
```

```{r}
fit.joineRML
```

```{r}
# simplify 
# try a generic way to create the list of formula


list(
    "ADAS13" = ADAS13 ~ age.fup, 
    "MMSE" = MMSE ~ age.fup)

?parse

parse(text = "ADAS13 ~ age.fup")

?formula
formula("ADAS13 ~ age.fup")


```

# Testing different sample size

follow-up: APOE4 may need one-hot encoding, not yet scaled the variables


```{r}
# Remove NA, why is it required?
df.long_censored_jm <- df.long_censored[
  !is.na(df.long_censored$ADAS13) & !is.na(df.long_censored$MMSE), ]
```

```{r}
# Similar size to example

set.seed(721)

ids <- df.long_censored_jm$id %>% sample(size = 200)

t.start <- Sys.time()

m.200 <- mjoint(
  formLongFixed = list(
    "ADAS13" = ADAS13 ~ age.fup, 
    "MMSE" = MMSE ~ age.fup),
  formLongRandom = list(
    "ADAS13" = ~ 1 | id, 
    "MMSE" = ~ 1 | id),
  formSurv = Surv(time, event) ~ AGE + PTGENDER + PTEDUCAT + status.bl + APOE4,
  data = list(
    df.long_censored_jm %>% filter(id %in% ids), 
    df.long_censored_jm %>% filter(id %in% ids)),
  timeVar = "Years.bl") # Did not use age.fup as time variable in LMM, due to error

t.end <- Sys.time()

cat("\nCompleted in", difftime(t.end, t.start, units = "mins"), "min")
```

```{r}
m.200
```



```{r}
# Increase size from n=200 to n=400
set.seed(721)

ids <- df.long_censored_jm$id %>% sample(size = 400)

t.start <- Sys.time()

m.400 <- mjoint(
  formLongFixed = list(
    "ADAS13" = ADAS13 ~ age.fup, 
    "MMSE" = MMSE ~ age.fup),
  formLongRandom = list(
    "ADAS13" = ~ 1 | id, 
    "MMSE" = ~ 1 | id),
  formSurv = Surv(time, event) ~ AGE + PTGENDER + PTEDUCAT + status.bl + APOE4,
  data = list(
    df.long_censored_jm %>% filter(id %in% ids), 
    df.long_censored_jm %>% filter(id %in% ids)),
  timeVar = "Years.bl") # Did not use age.fup as time variable in LMM, due to error

t.end <- Sys.time()

cat("\nCompleted in", difftime(t.end, t.start, units = "mins"), "min")
```

```{r}
m.400
```

## n=800

```{r}
# Increase size from n=200 to n=400
set.seed(721)

ids <- df.long_censored_jm$id %>% sample(size = 800)

t.start <- Sys.time()

m.800 <- mjoint(
  formLongFixed = list(
    "ADAS13" = ADAS13 ~ age.fup, 
    "MMSE" = MMSE ~ age.fup),
  formLongRandom = list(
    "ADAS13" = ~ 1 | id, 
    "MMSE" = ~ 1 | id),
  formSurv = Surv(time, event) ~ AGE + PTGENDER + PTEDUCAT + status.bl + APOE4,
  data = list(
    df.long_censored_jm %>% filter(id %in% ids), 
    df.long_censored_jm %>% filter(id %in% ids)),
  timeVar = "Years.bl") # Did not use age.fup as time variable in LMM, due to error

t.end <- Sys.time()

cat("\nCompleted in", difftime(t.end, t.start, units = "mins"), "min")
```

```{r}
m.800
```



# Changing number of LMMs

```{r}
# Remove NA, why is it required?
df.long_censored_jm <- df.long_censored[
  !is.na(df.long_censored$ADAS13) & !is.na(df.long_censored$MMSE) & !is.na(df.long_censored$RAVLT.immediate), ]
```

```{r}
# Similar size to example
set.seed(721)

ids <- df.long_censored_jm$id %>% sample(size = 400)

t.start <- Sys.time()

m.400_3 <- mjoint(
  formLongFixed = list(
    "ADAS13" = ADAS13 ~ age.fup, 
    "MMSE" = MMSE ~ age.fup,
    "RAVLT.immediate" = RAVLT.immediate ~ age.fup),
  formLongRandom = list(
    "ADAS13" = ~ 1 | id, 
    "MMSE" = ~ 1 | id,
    "RAVLT.immediate" = ~ 1 | id),
  formSurv = Surv(time, event) ~ AGE + PTGENDER + PTEDUCAT + status.bl + APOE4,
  data = list(
    df.long_censored_jm %>% filter(id %in% ids), 
    df.long_censored_jm %>% filter(id %in% ids), 
    df.long_censored_jm %>% filter(id %in% ids)),
  timeVar = "Years.bl") # Did not use age.fup as time variable in LMM, due to error

t.end <- Sys.time()

cat("\nCompleted in", difftime(t.end, t.start, units = "mins"), "min")
```

```{r}
m.400_3
```


# four time covariates

```{r}
# Remove NA, why is it required?
df.long_censored_jm <- df.long_censored[
  !is.na(df.long_censored$ADAS13) & !is.na(df.long_censored$MMSE) & !is.na(df.long_censored$RAVLT.immediate) & !is.na(df.long_censored$RAVLT.learning), ]

# Similar size to example
set.seed(721)

ids <- df.long_censored_jm$id %>% sample(size = 400)

t.start <- Sys.time()

m.400_4 <- mjoint(
  formLongFixed = list(
    "ADAS13" = ADAS13 ~ age.fup, 
    "MMSE" = MMSE ~ age.fup,
    "RAVLT.immediate" = RAVLT.immediate ~ age.fup,
    "RAVLT.learning" = RAVLT.learning ~ age.fup),
  formLongRandom = list(
    "ADAS13" = ~ 1 | id, 
    "MMSE" = ~ 1 | id,
    "RAVLT.immediate" = ~ 1 | id,
    "RAVLT.learning" = ~ 1 | id),
  formSurv = Surv(time, event) ~ AGE + PTGENDER + PTEDUCAT + status.bl + APOE4,
  data = list(
    df.long_censored_jm %>% filter(id %in% ids), 
    df.long_censored_jm %>% filter(id %in% ids), 
    df.long_censored_jm %>% filter(id %in% ids), 
    df.long_censored_jm %>% filter(id %in% ids)),
  timeVar = "Years.bl") # Did not use age.fup as time variable in LMM, due to error

t.end <- Sys.time()

cat("\nCompleted in", difftime(t.end, t.start, units = "mins"), "min")
```

```{r}
m.400_4
```


# Scale up
## Load data
```{r}
# Load data
# Contains two dataframes df.surv_preds and df.long_censored
load("adni_cleaned_prc.RData")

data.surv <- df.surv_preds_prc
data.long <- df.long_censored

```

```{r}
count_non_na <- function(x){sum(!is.na(x))} # Count number of non-NA values in a vector

# Construct df for each covariate to inspect frequency of non-NA values per subject
res.count_non_na <- df.long_censored %>% 
  group_by(id) %>% # Per subject
  dplyr::summarize(across(all_of(y.names), count_non_na)) # Count non-NA
```

```{r}
# Any subject without observation
y_any_sub_no_obs <- res.count_non_na %>% dplyr::summarise(across(all_of(y.names), function(x){any(x==0)}))

# Apply PRC without any filtering step, now works for longitudinal covariates that all subjects have at least 1 observation
y.names_subset <- y.names[y_any_sub_no_obs == FALSE]

y.names_subset
```

```{r}

```

