---
title: "pCox"
author: "Yibin Feng"
date: '2022-03-10'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Reference

https://glmnet.stanford.edu/articles/Coxnet.html

# Dependencies

```{r}
library(tidyverse)
library(glmnet)
```

# Load cleaned data

```{r}
load("adni_cleaned.RData")
```

# Format data

```{r}
# Input matrix, of dimension n obs x n vars; each row is an observation vector


x <- df.surv_preds %>% 
  select(RID, AGE, PTGENDER, PTEDUCAT, status.bl, APOE4, ADAS13.bl, MMSE.bl, RAVLT.immediate.bl, RAVLT.learning.bl, FAQ.bl) %>%
  na.omit() # Remove subjects with missing values
  
y.raw <- df.surv_preds %>% 
  filter(RID %in% x$RID) %>%
  select(time, event)

x.mat <- model.matrix(~. -RID, data = x)

y <- survival::Surv(time = y.raw$time, 
          event = y.raw$event,
          type = "right")
```

# Lasso

```{r}
alpha <- 1 # lasso penalty

fit <- glmnet(x.mat, y, 
              family = "cox",
              alpha = alpha) # elasticnet mixing param

summary(fit)

plot(fit, label = TRUE) # regularization path

plot(x = fit$lambda, y = fit$dev.ratio)
```

# Ridge

```{r}
# grid starts from 1e-5 to 3*1e4
lambdaGrid <- seq(0.00001, 30000, length.out=200) / (1000)

# Supply instead a decreasing sequence of lambda values. glmnet relies on its warms starts for speed, and its often faster to fit a whole path than compute a single fit.
lambdaGrid <- sort(lambdaGrid, decreasing=TRUE)

plot(lambdaGrid,
     main="lambda grid",
     cex=0.5,
     ylab="lambda")
```


```{r}
alpha <- 0 # ridge penalty

fit <- glmnet(x.mat, y, 
              family = "cox",
              alpha = alpha) # elasticnet mixing param

summary(fit)

plot(fit, label = TRUE) # regularization path

plot(x = log(fit$lambda), y = fit$dev.ratio)
```

```{r}
plot(survival::survfit(fit, x = x.mat, y = y)[[1]])
```


# Cross validation

```{r}
set.seed(721)

cvfit <- cv.glmnet(x.mat, y, 
                   family = "cox",
                   alpha = 0,
                   nfolds = 10,
                   type.measure = "C") # type.measure="C" is Harrel's concordance measure, only available for cox models

plot(cvfit)

cvfit$lambda.min

cvfit$lambda.1se
```


```{r}
# Predicted survival probability of mean pseudo subject in dataset
plot(survival::survfit(cvfit, s = "lambda.min", x = x.mat, y = y))
```

```{r}
# Inspect coefficients in optimal model
coef(cvfit, s = "lambda.min")
```



```{r}
# Inspect covariates of selected subjects
df.surv_preds[c(1, 1000),] %>% 
  select(RID, time, status, AGE, PTGENDER, PTEDUCAT, status.bl, APOE4, ADAS13.bl, MMSE.bl, RAVLT.immediate.bl, RAVLT.learning.bl, FAQ.bl)
```




```{r}
# Predicted survival probability for subject RID 30 and 4300
plot(survival::survfit(cvfit, s = "lambda.min", x = x.mat, y = y,
                       newx = x.mat[c(1,1000),]))
title("Predicted survival probability")
```




